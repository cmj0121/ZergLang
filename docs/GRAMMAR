# Grammar for Zerg
#
# Author cmj <cmj@cmj.tw>

# ======== Start of Grammar ========
# Grammatical Elements and Rules
#
#   - Upper case names (NAME) denote pre-defined token type.
#   - Strings with single quotes denote KEYWORDS
#
# Grammar Syntax
#
#   - rule_name ::= expression       The general grammar syntax for rule name and related expression.
#   - e1 e2                          The expression match e1, then match e2.
#   - e1 | e2                        The expression match e1 or e2.
#   - ( e )                          The expression match e which may follow extra notation.
#   - e?                             The expression optionally match e.
#   - e*                             The expression match zero or more occurrences of e.
#   - e+                             The expression match one or more occurrences of e.

# ======== Start of Rules ========
file   ::= source EOF
source ::= import_stmt* block*
scope  ::= '{' source '}'

# Import another source file or pre-compiled object file, search from current directory,
# standard library, and other directories specified by command line arguments.
#
# It may be the local file package or git repository
import_stmt   ::=  ( import_single | import_multi ) NEWLINE
import_single ::= 'import' import_expr
import_multi  ::= 'import' '(' ( import_expr NEWLINE )+ ')'
import_expr    ::= STRING ( 'as' NAME )?

block ::= ( expr_stmt | func_stmt )

# the stament which may be an expression or assignment, which is the most
# common statement in Zerg.
expr_stmt ::= ( expression | assignment ) NEWLINE

# the statement to define a new variable with the optional type, or update the value
# of a declared variable with the same type.
#
# The constant variable is immutable, stored in the read-only memory, and can not be
# changed after declaration.
assignment   ::= typed_assign | muted_assign
typed_assign ::= 'const'? NAME ':' type? '=' expression
muted_assign ::= NAME '=' expression

# the statement to define a routine function which may be called by other
# functions or expressions.
#
# It may be a public function which can be called by other source file.
func_stmt ::= pub? fn func_head scope
func_head ::= NAME '(' func_args? ')' type_hint?
func_args ::= func_arg ',' named_args | named_args

named_args ::= NAME ':' type
type_hint  ::= '->' type
type       ::= NAME

# ======== Start of Expressions ========
expression  ::= exclusive

# The logical expression which execute from left to right and short-circuit
# the evaluation if the result is determined.
exclusive   ::= disjunction 'xor' exclusive | disjunction
disjunction ::= conjunction 'or' disjunction | conjunction
conjunction ::= inversion 'and' conjunction | inversion
inversion   ::= 'not' inversion | comparison

# The comparison expression which execute from left to right and both side
# are evaluated, compared and return the truth result of comparison.
comparison ::= bitwise_or compare_op bitwise_or
compare_op ::= ( '>=' | '>' | '==' | '!=' | '<=' | '<' )

# The bitwise expression which execute from left to right and both side
# are evaluated, compared and return the result.
bitwise_or    ::= bitwise_xor '|' bitwise_or | bitwise_xor
bitwise_xor   ::= bitwise_and '^' bitwise_xor | bitwise_and
bitwise_and   ::= bitwise_shift '&' bitwise_and | bitwise_shift
bitwise_shift ::= sum ( '<<' | '>>' ) bitwise_shift | sum

sum     ::= term ( '+' | '-' ) sum | term
term    ::= factor ( '*' | '/' | '%' ) term | factor
factor  ::= ( '+' | '-' | '~' ) factor | primary
primary ::= primary '.' NAME | atom
atom    ::= NAME | STRING | NUMBER | CHAR | 'true' | 'false' | 'nil'

pub   ::= 'pub'
